---
title: "Dependent t-test"
author: "Daniel Lakens, D.Lakens@tue.nl"
output: word_document
---
```{r, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
####################################
#######  How to use ################
####################################

# 1) Install the packages and software specified below. 
# 2) Define the variable names, change the default settings, if desired
# 3) Hit Knit Word! (Output takes about a two minutes, mainly do bootstrapping the robust effect size and calculating the Bayesian Highest Density Iinterval)

####################################
######  FIRST TIME ONLY ############
####################################

#First time user? Install packages below by removing # and running the install commands, then install WRS for the Wilcox robust statistics functions.

#install.packages(c("MASS", "akima", "robustbase", "cobs", "robust", "mgcv", "scatterplot3d", "quantreg", "rrcov", "lars", "pwr", "trimcluster", "multicore", "mc2d", "psych", "Rfit","MBESS", "BayesFactor", "PoweR", "ggplot2", "reshape2", "plyr", "devtools","rmarkdown","gmodels", "HLMdiag", "car", "gridExtra", "BootES", "BEST", "plyr", "reshape2", "knitcitations"))

#Installation of the robust statistics package: Remove # in front of each of 4 lines below and run the code

#install.packages("devtools")
#library("devtools")
#install_github("mrxiaohe/WRScpp")
#install_github("nicebread/WRS", subdir="pkg")

#Download and install JAGS to clculate Bayesian HDI: http://sourceforge.net/projects/mcmc-jags/files/JAGS/

###################################
## Define variables names below ###
###################################

#Copy paste your data into a spreadsheet. Create 3 columns. On the first row, type the name of the variables. One column should contain the subject identifer (e.g., PPNR). The other two rows should contain the data from the two within-subject conditions. Make sure there is no missing data (or emtpy cells underneath the data - check in .txt file).
#Save your data as a .txt file - select Text (tab delimited)(*.txt).

setwd("C:/")   # set working directory (i.e., the location of your data file).
alldata <- read.delim("Stroop.txt", header=TRUE) #Define the name of the tab delimited txt file in the working directory that contains 3 columns: a subject identifier and 2 columns of the data in the two within-subject conditions.

alldata<-na.omit(alldata)#rows with missing data are removed

#IMPORTANT: Do not use spaces in names. If variable names in your file include spaces, change the names.

#Define names of the two columns in alldata you want to compare. Difference is computed as x-y (so reverse labels as desired) 
xlabel<-"Congruent"
ylabel<-"Incongruent"

#Define name of individual subject identifier variable (e.g., the participantnumber)
subject<-"PPNR"

#Define name of the factor that describes the difference between x and y (e.g., condition, time).
factorlabel<-"congruency"

#Define name of the measure that describes the values of x and y (e.g., reaction times, self-reported happiness)
measurelabel<-"reactiontimes"

#Below names for axis are used. These CAN include spaces.
xlabelstring<-"Condition" #define variables to be used for axis (can be replaced by "Any Label")
ylabelstring<-"reaction times (in seconds)"  #define variables to be used for axis

#Set your alpha level and confidence interval
alpha<-0.05
ConfInt<-0.95

#For the Bayes Factor, specify which effect you expect. Standard to 0.5 (small effect). Change to 0.707 (medium effect) or 1 (large effect).
BFrscale<-0.5

#Alternative hypothesis: specify "two.sided" (for x<>y), "less" (for x<y) or "greater" (for x>y)
H1<-"two.sided"

#Calculating the Bayesian HDI and Bootstrapping the effect size for robust statistics can take quite some time (e.g., 30 minutes) in large sample sizes. If you are in a hurry, set the variable below to "YES", if you want the HDI and Bootstrapped ES, set it to "NO"
InAHurry<-"NO"

#############################################################
### Changed the information above? Then hit 'Knit Word' #####
#############################################################
#################### Know your way around R? ################ 
############ Feel free to change the script below ###########
#############################################################

options(scipen=20) #disable scientific notation for numbers smaller than x (i.e., 10) digits (e.g., 4.312e+22)

#create two variables (x and y) that contain values of two datasets to be compared
x<-alldata[[xlabel]]
y<-alldata[[ylabel]]
diff<-x-y #difference scores

# Convert alldata to long format
library(reshape2)
alldata.long <- melt(alldata, id.vars = subject, measure.vars = c(xlabel,ylabel), variable.name = factorlabel,value.name = measurelabel)

#######################################################################
#######################################################################
########### Calculate CI for within and between #######################
################ Scripts from Baguley, 2012 ###########################
#######################################################################
#######################################################################

cm.ci <- function(data.frame, conf.level = ConfInt, difference = TRUE) {
  #cousineau-morey within-subject CIs
  k = ncol(data.frame)
  if (difference == TRUE) 
    diff.factor = 2^0.5/2
  else diff.factor = 1
  n <- nrow(data.frame)
  df.stack <- stack(data.frame)
  index <- rep(1:n, k)
  p.means <- tapply(df.stack$values, index, mean)
  norm.df <- data.frame - p.means + (sum(data.frame)/(n * k))
  t.mat <- matrix(, k, 1)
  mean.mat <- matrix(, k, 1)
  for (i in 1:k) t.mat[i, ] <- t.test(norm.df[i])$statistic[1]
  for (i in 1:k) mean.mat[i, ] <- colMeans(norm.df[i])
  c.factor <- (k/(k - 1))^0.5
  moe.mat <- mean.mat/t.mat * qt(1 - (1 - conf.level)/2, n - 1) * c.factor * 
    diff.factor
  ci.mat <- matrix(, k, 2)
  dimnames(ci.mat) <- list(names(data.frame), c("lower", "upper"))
  for (i in 1:k) {
    ci.mat[i, 1] <- mean.mat[i] - moe.mat[i]
    ci.mat[i, 2] <- mean.mat[i] + moe.mat[i]
  }
  ci.mat
}

bs.ci <- function(data.frame, conf.level = ConfInt, difference = FALSE) {
  # between-subject CIs
  k = ncol(data.frame)
  n <- nrow(data.frame)
  df.stack <- stack(data.frame)
  group.means <- colMeans(data.frame, na.rm = TRUE)
  if (difference == TRUE) 
    ci.mat <- (confint(lm(values ~ 0 + ind, df.stack)) - group.means) * 
    2^0.5/2 + group.means
  else ci.mat <- confint(lm(values ~ 0 + ind, df.stack))
  dimnames(ci.mat) <- list(names(data.frame), c("lower", "upper"))
  ci.mat
}

#change matrix output from functions to dataframe, add CI from between, add labels and means 
ci.sum<-as.data.frame(cm.ci(alldata[2:3]))
ci.sum[[factorlabel]] <- c(xlabel,ylabel)
ci.sum[[measurelabel]] <- c(mean(x),mean(y))
ci.sum[["lower.between"]] <- as.data.frame(bs.ci(alldata[2:3]))$lower
ci.sum[["upper.between"]] <- as.data.frame(bs.ci(alldata[2:3]))$upper

##################################################################
##################################################################
######## PLOT DATA AND CHECK FOR OUTLIERS AND NORMALITY ##########
##################################################################
##################################################################

#Test normality (p<.05 means normality assumption is violated). Kolmogorov-Smirnov (K-S) test is often used, but no longer recommended 
#In very large samples, tests for normality can result in significant results even when data is normally distributed. Look at a plot of the data.
#In very small samples (e,g., n = 10), deviations from normality might not be detected, but this does not mean the data is normally distributed.

require(PoweR)
statcompute(21, diff, levels = c(0.05)) #Shapiro-Wilk
statcompute(6, diff, levels = c(0.05)) #D'Agostino-Pearson
statcompute(2, diff, levels = c(0.05)) #Anderson-Darling
statcompute(7, diff, levels = c(0.05)) #Jarque-Berra
normalityrejections<-(statcompute(21, diff, levels = c(0.05))$decision + statcompute(6, diff, levels = c(0.05))$decision + statcompute(2, diff, levels = c(0.05))$decision + statcompute(7, diff, levels = c(0.05))$decision)

cat("The normality assumption was rejected in ",normalityrejections," out of 4 normality tests (Anderson-Darling, D'Agostino-Pearson, and Shapiro-Wilk).",sep="")

#Add difference to alldata dataframe for plotting.
alldata[["diff"]] <- diff

#normal Q-Q plot for difference (mean dv). Points should fall on line (in word doc ggplot function is used, see below)
require(HLMdiag)

#Draw scatterplot with 2 boxplots used in word document
#Code adapted from: https://github.com/SandyMuspratt/ScatterBoxPlot/blob/master/mtcars%20marginal%20boxplots.R by Sandy Muspratt

require(ggplot2)
require(gtable)

# Main scatterplot
p1 <- ggplot(alldata, aes(x=eval(parse(text=paste(xlabel))), y=eval(parse(text=paste(ylabel))))) + 
  geom_point() +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) + 
  expand_limits(y = c(min(alldata[[ylabel]]) - 0.1 * diff(range(alldata[[ylabel]])), 
                      max(alldata[[ylabel]]) + 0.1 * diff(range(alldata[[ylabel]])))) + 
  expand_limits(x = c(min(alldata[[xlabel]]) - 0.1 * diff(range(alldata[[xlabel]])), 
                      max(alldata[[xlabel]]) + 0.1 * diff(range(alldata[[xlabel]])))) + 
  theme_bw(base_size=14) +
  ylab(ylabel)  + xlab(xlabel) +
  theme(plot.margin= unit(c(0, 0, 0.5, 0.5), "lines"))
  
# To remove all axis labelling and marks from the two marginal plots
theme_remove_all <- theme(axis.text = element_blank(),
                          axis.title = element_blank(),
                          axis.ticks =  element_blank(),
                          axis.ticks.margin = unit(0, "lines"),
                          axis.ticks.length = unit(0, "cm"))

# Horizontal marginal boxplot - to appear at the top of the chart
p2 <- ggplot(alldata, aes(x = factor(1), y = eval(parse(text=paste(xlabel))))) + 
  geom_boxplot() +
#  geom_jitter(position = position_jitter(width = 0.05)) +
  scale_y_continuous(expand = c(0, 0)) + 
  expand_limits(y = c(min(alldata[[xlabel]]) - 0.1 * diff(range(alldata[[xlabel]])), 
                      max(alldata[[xlabel]]) + 0.1 * diff(range(alldata[[xlabel]])))) + 
  coord_flip() +
  theme_bw(base_size=14) +
  theme_remove_all +
  theme(plot.margin= unit(c(0.5, 0, 0, 0.5), "lines"))

# Vertical marginal boxplot - to appear at the right of the chart
p3 <- ggplot(alldata, aes(x = factor(1), y = eval(parse(text=paste(ylabel))))) + 
  geom_boxplot() +
#  geom_jitter(position = position_jitter(width = 0.05)) +
  scale_y_continuous(expand = c(0, 0)) + 
  expand_limits(y = c(min(alldata[[ylabel]]) - 0.1 * diff(range(alldata[[ylabel]])), 
                      max(alldata[[ylabel]]) + 0.1 * diff(range(alldata[[ylabel]])))) + 
  theme_bw(base_size=14) +
  theme_remove_all +
  theme(plot.margin= unit(c(0, 0.5, 0.5, 0), "lines"))

# Get the gtables
gt1 <- ggplot_gtable(ggplot_build(p1))
gt2 <- ggplot_gtable(ggplot_build(p2))
gt3 <- ggplot_gtable(ggplot_build(p3))

# Get maximum widths and heights for x-axis and y-axis title and text
maxWidth = unit.pmax(gt1$widths[2:3], gt2$widths[2:3])
maxHeight = unit.pmax(gt1$heights[4:5], gt3$heights[4:5])

# Set the maximums in the gtables for gt1, gt2 and gt3
gt1$widths[2:3] <- as.list(maxWidth)
gt2$widths[2:3] <- as.list(maxWidth)

gt1$heights[4:5] <- as.list(maxHeight)
gt3$heights[4:5] <- as.list(maxHeight)

# Combine the scatterplot with the two marginal boxplots
# Create a new gtable
gt <- gtable(widths = unit(c(7, 1), "null"), height = unit(c(1, 7), "null"))

# Instert gt1, gt2 and gt3 into the new gtable
gt <- gtable_add_grob(gt, gt1, 2, 1)
gt <- gtable_add_grob(gt, gt2, 1, 1)
gt <- gtable_add_grob(gt, gt3, 2, 2)

# And render the plot
grid.newpage()
grid.draw(gt)

#histogram for x
ggplot(alldata, aes(x=eval(parse(text=paste(xlabel)))))  + 
  geom_histogram(colour="black", fill="grey") +
  xlab(ylabelstring) + theme_bw(base_size=14)
#histogram for y
ggplot(alldata, aes(x=eval(parse(text=paste(ylabel)))))  + 
  geom_histogram(colour="black", fill="grey") +
  xlab(ylabelstring) + theme_bw(base_size=14)

#histogram for difference scores
ggplot(alldata, aes(x=diff))  + 
  geom_histogram(colour="black", fill="grey") +
  xlab(ylabelstring) + theme_bw(base_size=14)

#density plot with normal distribution (red) and kernel desity plot
ggplot(alldata, aes(x=diff))  + 
  geom_histogram(colour="black", fill="grey", aes(y = ..density..)) +
  stat_function(fun = dnorm, args = c(mean=mean(alldata$diff), sd=sd(alldata$diff)), size = 1, color = "red", lty=2) +
  geom_density(fill=NA, colour="black", size = 1) +
  xlab(ylabelstring) + ggtitle("Difference scores") + theme_bw(base_size=14) 

require(gridExtra)
#density plot with normal distribution (red) and kernel desity plot
p1<-ggplot(alldata, aes(x=eval(parse(text=paste(xlabel)))))  + 
  geom_histogram(colour="black", fill="grey", aes(y = ..density..)) +
  stat_function(fun = dnorm, args = c(mean=mean(x), sd=sd(x)), size = 1, color = "red", lty=2) +
  geom_density(fill=NA, colour="black", size = 1) +
  xlab(ylabelstring)  + ggtitle(xlabel)+ theme_bw(base_size=14) 
#density plot with normal distribution (red) and kernel desity plot
p2<-ggplot(alldata, aes(x=eval(parse(text=paste(ylabel)))))  + 
  geom_histogram(colour="black", fill="grey", aes(y = ..density..)) +
  stat_function(fun = dnorm, args = c(mean=mean(y), sd=sd(y)), size = 1, color = "red", lty=2) +
  geom_density(fill=NA, colour="black", size = 1) +
  xlab(ylabelstring) + ggtitle(ylabel) + theme_bw(base_size=14) 

  grid.arrange(p1, p2, ncol=2)

#Q-Q plot
ggplot_qqnorm(diff, line = "quantile")+ theme_bw(base_size=14)

#Testing equality of variances

require(car)
pvalueLevene<-leveneTest(alldata.long[[measurelabel]] ~ as.factor((alldata.long[[factorlabel]])))$"Pr(>F)"[1:1]
if (pvalueLevene < 0.05){equalvar<-"the assumption that variances are equal is rejected (consider reporting robust statistics)."}
if (pvalueLevene >= 0.05){equalvar<-"the assumption that variances are equal is not rejected."}
cat("Levene's test for equality of variances (p = ", round(pvalueLevene, digits=2),") indicates that ",equalvar,sep="")


##########################################################################################
##########################################################################################
#####################Calculate CI around Cohen's d for within designs ####################
##########################################################################################
##########################################################################################

#Calculate based on data
r<-cor(x, y) #correlation between dependent measures
m_diff<-mean(diff) #mean of difference scores
s_diff<-sd(diff) #standard deviation of difference scores
sd1<-sd(x) #standard deviation of group 1
sd2<-sd(y) #standard deviation of group 2
N <- length(x) #number of pairs

ttestresult<-t.test(x, y, alternative = H1, paired = TRUE, var.equal = TRUE, conf.level = ConfInt)
tvalue<-ttestresult$statistic #store t-value from dependent t-test
pvalue<-ttestresult$p.value #store p-value from dependent t-test
CI_diff<-ttestresult$conf.int #store confidence interval of mean difference
s_av <- sqrt((sd1^2+sd2^2)/2) #calculate average standard deviation for effect size calculation

#Specify direction of difference
if (mean(x)>mean(y)){direction<-"greater than"}
if(mean(x)<mean(y)){direction<-"smaller than"}
if(pvalue < alpha){surprising<-"surprising"}
if(pvalue >= alpha){surprising<-" not surprising"}

#Effect sizes and 95% CI
#Cohen's d_av, using s_av as standardizer

require(MBESS) # to calculate non-central t limits

d_av <- m_diff/s_av
d_unb <- (1-(3/(4*(N-1)-1)))*d_av #note this is approximation of correction for Hedges'g - ESCI uses accurate correction, so should we.
nct_limits <- conf.limits.nct(t.value = tvalue, df=N-1, conf.level = ConfInt)
ci_l_d_av <- nct_limits$Lower.Limit*s_diff/(s_av*sqrt(N))
ci_u_d_av <- nct_limits$Upper.Limit*s_diff/(s_av*sqrt(N))

#Interpret size of effect (last resort - use only if effect size cannot be compared to other relevant effects in the literature)
if (abs(d_av) < 0.2){effectsize<-"tiny"}
if (0.2 <= abs(d_av) && abs(d_av) < 0.5){effectsize<-"small"}
if (0.5 <= abs(d_av) && abs(d_av) < 0.8){effectsize<-"medium"}
if (abs(d_av) >= 0.8){effectsize<-"large"}

#Cohen's d_z, using s_diff as standardizer
d_z <- tvalue/sqrt(N)
ci_l_d_z <- nct_limits$Lower.Limit/sqrt(N) #Not sure about this formula, but gives same results as Wuensch's files
ci_u_d_z <- nct_limits$Upper.Limit/sqrt(N) #Not sure about this formula

#Common Langaue Effect Size (McGraw & Wong, 1992)
CL<-pnorm(abs(m_diff/s_diff))

#Robust Statistics (if normality is violated)

require(WRS)

#yuendv2 compared dependent groups, returns explanatory ES (Wilcox, 2012, p.197)
# explanatory power (Xi) is the robust equivalent of omega squared (unbiased eta squared, or r squared)
# explanatory power is related to d_z in size, not to d_av. 
#d = 0.2, 0.5 and 0.8 roughly correspond to small, medium and large effect sizes, respectively.
#This convention corresponds approximately to Xi = 0.15, 0.35 and 0.50 
yuend<-yuendv2(x,y, tr=0.2,alpha=ConfInt)
if(yuend$p.value < alpha){surprising2<-"surprising"}
if(yuend$p.value >= alpha){surprising2<-" not surprising"}

cat("Using the Yuen-Welch method for comparing 20% trimmed means showed the mean difference between conditions (M = ",round(yuendv2(x,y, tr=0.2,alpha=ConfInt)$dif, digits = 2),", 95% CI [", round(yuend$ci[1], digits = 2),";",round(yuend$ci[2], digits = 2),"]) was statistically different from zero, t(",yuend$df,") = ",round(yuend$teststat, digits = 2),", p = ",round(yuend$p.value, digits = 2),", Xi = ", round(yuend$Effect.Size, digits=2),sep = "")

#Interpret size of effect (last resort - use only if effect size cannot be compared to other relevant effects in the literature)

if (abs(yuend$Effect.Size) < 0.15){effectsize2<-"tiny"}
if (0.15 <= abs(yuend$Effect.Size) && abs(yuend$Effect.Size) < 0.35){effectsize2<-"small"}
if (0.35 <= abs(yuend$Effect.Size) && abs(yuend$Effect.Size) < 0.5){effectsize2<-"medium"}
if (abs(yuend$Effect.Size) >= 0.5){effectsize2<-"large"}

#BayesFactor
require(BayesFactor) #To calculate Bayes Factor

if(H1 == "two.sided"){
  BF <- ttest.tstat(t = tvalue, n1 = N, rscale = BFrscale, simple=TRUE)
} else if (H1 == "greater"){
  BF <- ttest.tstat(t = tvalue, n1 = N, nullInterval = c(0, Inf), rscale = BFrscale, simple=TRUE)
} else if (H1 == "less"){
  BF <- ttest.tstat(t = tvalue, n1 = N, nullInterval = c(-Inf, 0), rscale = BFrscale, simple=TRUE)
}

if(BF!=Inf){round(BF, digits=2)}
if(BF==Inf){BF<-"practically infinitely high"}

#Download and install JAGS: http://sourceforge.net/projects/mcmc-jags/files/JAGS/

require(BEST) #To calculate HIB
if(InAHurry!="YES"){BESTout1g<-BESTmcmc(diff)}
ifelse((InAHurry!="YES"),mu<-summary(BESTout1g)[1,1],mu<-"NOT CALCULATED DUE TO TIME CONSTRAINTS")
ifelse((InAHurry!="YES"),HDI_l<-summary(BESTout1g)[1,5],HDI_l<-"NOT CALCULATED")
ifelse((InAHurry!="YES"),HDI_u<-summary(BESTout1g)[1,6],HDI_u<-"NOT CALCULATED")

#Interpret strength of evidence of Bayes Factor following Jeffreys (1961)
if (0.33 < BF && BF <= 1){evidence<-"anecdotal evidence for H0"}
if (0.1 < BF && BF <=0.33){evidence<-"moderate evidence for H0"}
if (0.03 < BF && BF <= 0.1){evidence<-"strong evidence for H0"}
if (0.01 < BF && BF <= 0.03){evidence<-"very strong evidence for H0"}
if (BF <=0.01){evidence<-"decisive evidence for H0"}
if (1 < BF && BF <= 3){evidence<-"anecdotal evidence for H1"}
if (3 < BF && BF <=10){evidence<-"moderate evidence for H1"}
if (10 < BF && BF <= 30){evidence<-"strong evidence for H1"}
if (30 < BF && BF <= 100){evidence<-"very strong evidence for H1"}
if (BF > 100){evidence<-"decisive evidence for H1"}

```

This document summarizes a comparison between two independent groups, comparing `r ylabelstring` between the `r xlabel` and `r ylabel` conditions. This script can help to facilitate the (re-)analysis of data, and the word-output might prevent copy-paste errors when transferring results to a manuscript.

Researchers can base their statistical inferences on Frequentist or robust statistics, as well as on Bayesian statistics. Effect sizes and their confidence intervals are provided, thus inviting researchers to interpret their data from multiple perspectives. 

Checking for outliers, normality, equality of variances.
------

###Outliers

Boxplots can be used to identify outliers. Boxplots give the median (thick line), and 25% of the data above and below the median (box). End of whiskers are the maximum and minimum value when excluding outliers (which are indicated by dots). 

```{r, echo=FALSE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=4, fig.heigth=4, dpi=300}
#Draw scatterplot with 2 boxplots
#Code adapted from: https://github.com/SandyMuspratt/ScatterBoxPlot/blob/master/mtcars%20marginal%20boxplots.R by Sandy Muspratt

require(ggplot2)
require(gtable)

# Main scatterplot
p1 <- ggplot(alldata, aes(x=eval(parse(text=paste(xlabel))), y=eval(parse(text=paste(ylabel))))) + 
  geom_point(alpha = 0.35) +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) + 
  expand_limits(y = c(min(alldata[[ylabel]]) - 0.1 * diff(range(alldata[[ylabel]])), 
                      max(alldata[[ylabel]]) + 0.1 * diff(range(alldata[[ylabel]])))) + 
  expand_limits(x = c(min(alldata[[xlabel]]) - 0.1 * diff(range(alldata[[xlabel]])), 
                      max(alldata[[xlabel]]) + 0.1 * diff(range(alldata[[xlabel]])))) +
  theme_bw(base_size=14) +
  ylab(ylabel)  + xlab(xlabel) +
  theme(plot.margin= unit(c(0, 0, 0.5, 0.5), "lines"))
  
# To remove all axis labelling and marks from the two marginal plots
theme_remove_all <- theme(axis.text = element_blank(),
                          axis.title = element_blank(),
                          axis.ticks =  element_blank(),
                          axis.ticks.margin = unit(0, "lines"),
                          axis.ticks.length = unit(0, "cm"))

# Horizontal marginal boxplot - to appear at the top of the chart
p2 <- ggplot(alldata, aes(x = factor(1), y = eval(parse(text=paste(xlabel))))) + 
  geom_boxplot() +
#  geom_jitter(position = position_jitter(width = 0.05)) +
  scale_y_continuous(expand = c(0, 0)) + 
  expand_limits(y = c(min(alldata[[xlabel]]) - 0.1 * diff(range(alldata[[xlabel]])), 
                      max(alldata[[xlabel]]) + 0.1 * diff(range(alldata[[xlabel]])))) + 
  coord_flip() +
  theme_bw(base_size=14) +
  theme_remove_all +
  theme(plot.margin= unit(c(0.5, 0, 0, 0.5), "lines"))

# Vertical marginal boxplot - to appear at the right of the chart
p3 <- ggplot(alldata, aes(x = factor(1), y = eval(parse(text=paste(ylabel))))) + 
  geom_boxplot() +
#  geom_jitter(position = position_jitter(width = 0.05)) +
  scale_y_continuous(expand = c(0, 0)) + 
  expand_limits(y = c(min(alldata[[ylabel]]) - 0.1 * diff(range(alldata[[ylabel]])), 
                      max(alldata[[ylabel]]) + 0.1 * diff(range(alldata[[ylabel]])))) + 
  theme_bw(base_size=14) +
  theme_remove_all +
  theme(plot.margin= unit(c(0, 0.5, 0.5, 0), "lines"))

# Get the gtables
gt1 <- ggplot_gtable(ggplot_build(p1))
gt2 <- ggplot_gtable(ggplot_build(p2))
gt3 <- ggplot_gtable(ggplot_build(p3))

# Get maximum widths and heights for x-axis and y-axis title and text
maxWidth = unit.pmax(gt1$widths[2:3], gt2$widths[2:3])
maxHeight = unit.pmax(gt1$heights[4:5], gt3$heights[4:5])

# Set the maximums in the gtables for gt1, gt2 and gt3
gt1$widths[2:3] <- as.list(maxWidth)
gt2$widths[2:3] <- as.list(maxWidth)

gt1$heights[4:5] <- as.list(maxHeight)
gt3$heights[4:5] <- as.list(maxHeight)

# Combine the scatterplot with the two marginal boxplots
# Create a new gtable
gt <- gtable(widths = unit(c(7, 1), "null"), height = unit(c(1, 7), "null"))

# Instert gt1, gt2 and gt3 into the new gtable
gt <- gtable_add_grob(gt, gt1, 2, 1)
gt <- gtable_add_grob(gt, gt2, 1, 1)
gt <- gtable_add_grob(gt, gt3, 2, 2)

# And render the plot
grid.newpage()
grid.draw(gt)

```

##Normality assumption

The dependent *t*-test assumes that *difference* scores are normally distributed and that the variances of the two groups are equal. It does *not* assume the data within each measurement (so within the `r xlabel` and `r ylabel` condition) are normally distributed. If the normality assumption is violated, the Type 1 error rate of the test is no longer controlled, and can substantially increase beyond the chosen significance level. Formally, a normality test based on the data is incorrect, and the normality assumption should be tested on additional (e.g., pilot) data. Nevertheless, a two-step procedure (testing the data for normality, and using alternatives for the traditional *t*-test if normality is violated) works well (see [Rochon, Gondan, & Kieser, 2012](http://www.biomedcentral.com/1471-2288/12/81)).

###Tests for normality

[Yap and Sim (2011, p. 2153)](http://www.tandfonline.com/doi/pdf/10.1080/00949655.2010.520163) recommend: "If the distribution is symmetric with low kurtosis values (i.e. symmetric short-tailed distribution), then the D'Agostino-Pearson and Shapiro-Wilkes tests have good power. For symmetric distribution with high sample kurtosis (symmetric long-tailed), the researcher can use the JB, Shapiro-Wilkes, or Anderson-Darling test." The Kolmogorov-Smirnov (K-S) test is often used, but no longer recommended, and not included here.

If a normality test rejects the assumptions that the data is normally distributed (with *p* < .05) non-parametric or robust statistics have to be used (robust analyses are provided below).  

**The normality assumption was rejected in `r normalityrejections` out of 4 normality tests (Anderson-Darling, D'Agostino-Pearson, and Shapiro-Wilk).**

Test Name  | *p*-value 
------------- | -------------
Shapiro-Wilk  | *p* `r ifelse(statcompute(21, diff, levels = c(0.05))$pvalue>=0.001," = ", " < ")` `r ifelse(statcompute(21, diff, levels = c(0.05))$pvalue>=0.001, round(statcompute(21, diff, levels = c(0.05))$pvalue, digits=3), "0.001")`
D'Agostino-Pearson  | *p* `r ifelse(statcompute(6, diff, levels = c(0.05))$pvalue>0.001," = ", " < ")` `r ifelse(statcompute(6, diff, levels = c(0.05))$pvalue>0.001, round(statcompute(6, diff, levels = c(0.05))$pvalue, digits=3), "0.001")`
Anderson-Darling  | *p* `r ifelse(statcompute(2, diff, levels = c(0.05))$pvalue>0.001," = ", " < ")` `r ifelse(statcompute(2, diff, levels = c(0.05))$pvalue>0.001, round(statcompute(2, diff, levels = c(0.05))$pvalue, digits=3), "0.001")`
Jarque-Berra  | *p* `r ifelse(statcompute(7, diff, levels = c(0.05))$pvalue>0.001," = ", " < ")` `r ifelse(statcompute(7, diff, levels = c(0.05))$pvalue>0.001, round(statcompute(7, diff, levels = c(0.05))$pvalue, digits=3), "0.001")`

In very large samples (when the test for normality has close to 100% power) tests for normality can result in significant results even when data is normally distributed, based on minor deviations from normality. In very small samples (e.g., n = 10), deviations from normality might not be detected, but this does not mean the data is normally distributed.  Always look at a plot of the data in addition to the test results.

###Histogram, kernel density plot (black line) and normal distribution (red line) of difference scores

The density (or proportion of the observations) is plotted on the y-axis. The grey bars are a histogram of the difference scores. Judging whether data is normally distributed on the basis of a histogram depends too much on the number of bins (or bars) in the graph. A kernel density plot (a non-parametric technique for density estimation) provides an easier way to check the normality of the data by comparing the shape of the density plot (the black line) with a normal distribution (the red dotted line, based on the observed mean and standard deviation). For dependent t-tests, the main DV is the *difference score*, and therefore the difference score should be normally distributed.

```{r, echo=FALSE, message=FALSE, fig.width=6.3, dpi=300}

#density plot with normal distribution (red) and kernel desity plot
ggplot(alldata, aes(x=diff))  + 
  geom_histogram(colour="black", fill="grey", aes(y = ..density..)) +
  stat_function(fun = dnorm, args = c(mean=mean(alldata$diff), sd=sd(alldata$diff)), size = 1, color = "red", lty=2) +
  geom_density(fill=NA, colour="black", size = 1) +
  xlab(ylabelstring) + ggtitle("Difference scores") + theme_bw(base_size=14) 


require(gridExtra)
#density plot with normal distribution (red) and kernel desity plot
p1<-ggplot(alldata, aes(x=eval(parse(text=paste(xlabel)))))  + 
  geom_histogram(colour="black", fill="grey", aes(y = ..density..)) +
  stat_function(fun = dnorm, args = c(mean=mean(x), sd=sd(x)), size = 1, color = "red", lty=2) +
  geom_density(fill=NA, colour="black", size = 1) +
  xlab(ylabelstring)  + ggtitle(xlabel)+ theme_bw(base_size=14) 
#density plot with normal distribution (red) and kernel desity plot
p2<-ggplot(alldata, aes(x=eval(parse(text=paste(ylabel)))))  + 
  geom_histogram(colour="black", fill="grey", aes(y = ..density..)) +
  stat_function(fun = dnorm, args = c(mean=mean(y), sd=sd(y)), size = 1, color = "red", lty=2) +
  geom_density(fill=NA, colour="black", size = 1) +
  xlab(ylabelstring) + ggtitle(ylabel) + theme_bw(base_size=14) 

  grid.arrange(p1, p2, nrow=2)

```

Q-Q-plot
------

In the Q-Q plot for the difference scores the points should fall on the line. Deviations from the line in the upper and lower quartiles indicates the tails of the distributions are thicker or thinner than in the normal distribution. An S-shaped curve with a dip in the middle indicates data is left-skewed (more values to the right of the distribution), while a bump in the middle indicates data is right-skewed (more values to the left of the distribution). For interpretation examples, see [here](http://emp.byui.edu/BrownD/Stats-intro/dscrptv/graphs/qq-plot_egs.htm).

```{r, echo=FALSE, message=FALSE, fig.width=6.3, fig.height=3.6, dpi=300}

#Q-Q plot
ggplot_qqnorm(diff, line = "quantile") + ggtitle("Difference scores") + theme_bw(base_size=14)

qq1<-ggplot_qqnorm(x, line = "quantile") + ggtitle(xlabel) + theme_bw(base_size=14)
qq2<-ggplot_qqnorm(y, line = "quantile") + ggtitle(ylabel) + theme_bw(base_size=14)
grid.arrange(qq1, qq2, ncol=2)

```


##Equal variances assumption

In addition to the normality assumption, a second assumption of the *t*-test is that variances in both groups are equal. The variance is the standard deviation, squared, and the assumption is thus that the variance in the `r xlabel` condition (`r round(sd1^2, digits = 2)`) equals that in the `r ylabel` condition (`r round(sd2^2, digits = 2)`). [Markowski & Markowski (1990)](http://www.jstor.org/stable/2684360) show that if sample sizes are equal, violations of the equal variance assumption do not lead to unsatisfactory performance (defined as actual significance levels falling outside a 0.03-0.07 boundary for a nominal alpha level of 0.05). 

###Levene's test

This equality of variances assumption is typically examined with Levene's test, although in small samples, Levene's test can have low power, and thus fail to reject the null-hypothesis that variances are equal, even when they are unequal. Levene's test for equality of variances (*p* `r ifelse(pvalueLevene>0.001," = ", " < ")` `r ifelse(pvalueLevene>0.001, round(pvalueLevene, digits=3), "0.001")`) indicates that `r equalvar`


Comparing the two sets of data
------

###Frequentist statistics

A *p*-value is the probability of obtaining the observed result, or a more extreme result, assuming the null-hypothesis is true. It is not the probability that the null-hypothesis or the alternative hypothesis is true (for such inferences, see Bayesian statistics below). In repeated sampling, 95% of future 95% confidence intervals can be expected to contain the true population parameters (e.g, the mean difference or the effect size). Confidence intervals are not a statement about the probability that a single confidence interval contains the true population parameter, but a statement about the probability that future confidence intervals will contain the true population parameter. Hedges' *g* (also referred to as *d*~unbiased~, see Borenstein, Hedges, Higgins, & Rothstein, 2009) is provided as best estimate of Cohen's *d*, but the best estimate of the confidence interval is based on *d*~av~ (as recommended by Cumming, 2012). Hedges's *g* and the 95% CI around the effect size are calculated using the MBESS package by ([Kelley (2007](http://dx.doi.org/10.3758/BF03192993)). The common language effect size expresses the probability that in any random pairing of two observations from both groups, the observation from one group is higher than the observation from the other group, see [McGraw & Wong, 1992](http://dx.doi.org/10.1037/0033-2909.111.2.361). In a dependent *t*-test, the effect size Cohen's *d* can be calculated by using a standardizer that controls for the correlation between observations (*d*~av~) or not (*d*~z~). Both are provided, but *d*~av~ (or actually it's unbiased estimate, *g*~av~) is recommended. For a discussion, see [Lakens, 2013](http://journal.frontiersin.org/Journal/10.3389/fpsyg.2013.00863/full). Default interpretations of the size of an effect as provided here should only be used as a last resort, and it is preferable to interpret the size of the effect in relation to other effects in the literature, or in terms of its practical significance.

####Results

The mean `r ylabelstring` (*M* = `r round(mean(x), digits = 2)`, *SD* = `r round(sd1, digits = 2)`) of participants in the `r xlabel` condition was `r direction` the mean (*M* = `r round(mean(y), digits = 2)`, *SD* = `r round(sd2,digits=2)`) of participants in the `r ylabel` condition. The difference between measurements is (*M* = `r round(m_diff, digits=2)`, *SD* = `r round(s_diff, digits=2)`), 95% CI = [`r round(CI_diff[1:1], digits=2)`;`r round(CI_diff[2:2],digits=2)`], *t*(`r round(ttestresult$parameter, digits=2)`) = `r round(tvalue, digits=2)`, *p* `r ifelse(pvalue>0.001," = ", " < ")` `r ifelse(pvalue>0.001, formatC(round(pvalue, digits=3),digits=3, format="f"), "0.001")`, Hedges' *g* = `r round(d_unb, digits=2)`, 95% CI [`r round(ci_l_d_av, digits=2)`;`r round(ci_u_d_av, digits=2)`] (or d~z~ = `r round(d_z, digits=2)`, 95% CI [`r round(ci_l_d_z, digits=2)`;`r round(ci_u_d_z, digits=2)`]). This can be considered a `r effectsize` effect. The observed data is `r surprising` under the assumption that the null-hypothesis is true. The Common Language effect size (McGraw & Wong, 1992) indicates that after controlling for individual differences, the likelihood that a persons `r ylabelstring` in the `r xlabel` condition is `r direction` the `r ylabelstring` in the `r ylabel` condition is `r round(100*CL, digits=0)`%.

###Bayesian statistics

Bayesian statistics can quantify the relative evidence in the data for either the alternative hypothesis or the null hypothesis. Bayesian statistics require priors to be defined. In the Bayes Factor calculation reported below, a non-informative Jeffreys prior is placed on the variance of the normal population, while a Cauchy prior is placed on the standardized effect size (for details, [see Morey & Rouder, 2011](http://drsmorey.org/bibtex/upload/Morey:Rouder:2011.pdf)). Calculations are performed using the [BayesFactor package](http://cran.r-project.org/web/packages/BayesFactor/BayesFactor.pdf). Default interpretations of the strength of the evidence are provided but should not distract from the fact that strength of evidence is a continuous function of the Bayes Factor. A second popular Bayesian approach relies on estimation, and the mean posterior and 95% higest density intervals (HDI) are calculated following recommendations by [Kruschke, (2013)](http://www.indiana.edu/~kruschke/BEST/BEST.pdf) based on vague priors. According to Kruschke (2010, p. 34): 'The HDI indicates which points of a distribution we believe in most strongly. The width of the HDI is another way of measuring uncertainty of beliefs. If the HDI is wide, then beliefs are uncertain. If the HDI is narrow, then beliefs are fairly certain.'

####Results

The JZS BF~10~ (with r scale = `r BFrscale`) = `r round(BF, digits=2)`. This indicates the data are `r round(BF, digits = 2)` (or log(e) BF =`r round(log(BF), digits=2)`) times more probable under the alternative hypothesis, than under the null hypothesis. This data provides `r evidence`. The posterior mean difference is `r ifelse(InAHurry!="YES",round(mu, digits=2), "NOT CALCULATED")`, HDI = `r ifelse(InAHurry!="YES",round(HDI_l, digits=2), "NOT CALCULATED")`, `r ifelse(InAHurry!="YES",round(HDI_u, digits=2), "NOT CALCULATED")`.  

###Robust statistics

Values in the tails of the distribution can have a strong influence on the mean. If values in the tails differ from a normal distribution, the power of a test is reduced and the effect size estimates are biased, even under slight deviations from normality (Wilcox, 2012). One way to deal with this problem is to remove the tails in the analysis by using *trimmed means*. A recommended percentage of trimming is 20% from both tails (Wilcox, 2012), which means inferences are based on the 60% of the data in the middle of the distribution. Yuen's method can be used to compare trimmed means (when the percentage of trimming is 0%, Yuen's method reduces to Welch's *t*-test). The equivalent of Cohen's *d* for within designs is not yet available, so the explanatory effect size is reported ([Wilcox & Tian, 2011](http://dx.doi.org/10.1080/02664763.2010.498507)). Explanatory power (Xi, replace in the output below by the Greek lowercase Xi symbol) is the robust equivalent of omega squared (unbiased eta squared, or r squared), and thus the equivalent of related to *d*~z~ in size, not to *d*~av~. The effect size convention of small, medium, and large corresponds approximately to Xi = 0.15, 0.35 and 0.50. 

####Results

Using the Yuen-Welch method for comparing 20% trimmed means showed the mean difference in `r ylabelstring` between conditions is (*M* = `r round(yuend$dif, digits = 2)`, 95% CI [`r round(yuend$ci[1], digits = 2)`;`r round(yuend$ci[2], digits = 2)`]) was statistically different from zero, *t*(`r yuend$df`) = `r round(yuend$teststat, digits = 2)`, *p* `r ifelse(yuend$p.value>0.001," = ", " < ")` `r ifelse(yuend$p.value>0.001, formatC(round(yuend$p.value, digits = 2), digits=3, format="f"), "0.001")`, Xi = `r round(yuend$Effect.Size, digits=2)`. The observed data is `r surprising2` under the assumption that the null-hypothesis is true. This can be considered a `r effectsize2` effect.



Plotting data
------

**Graph examples. In the code, you can turn different layers on and off, and change their properties by adding or removing # in front of a line of code. Displays violin plot (rotated kernal density plots) and 95% CI bars (for between designs and adjusted for within designs following Morey (2008)), individual data-points, or simple bar graphs. **

###*Figure 1*. Means, violin plot, and two-tiered 95% within (crossbars) and between (endpoints of lines) confidence intervals following Baguley (2012), and violin plot. 

```{r, echo=FALSE,  fig.width=3, dpi=300}
#Example 1: means and two-tiered 95% CI (within and between) suggested by Baguley 
ggplot(ci.sum, aes(x=eval(parse(text=paste(factorlabel))), y=eval(parse(text=paste(measurelabel))), group=1)) +
#  geom_bar(position=position_dodge(.9), colour="black", stat="identity", fill="white") +
  geom_errorbar(width=.25, size=0.5, aes(ymin=lower, ymax=upper)) +
  geom_errorbar(width=0, size=1, aes(ymin=lower.between, ymax=upper.between)) +
  geom_point(size=2) +
#  geom_point(data=alldata.long) +
  geom_violin(data=alldata.long, aes(group=eval(parse(text=paste(factorlabel)))), alpha=0) +
  ylab(ylabelstring)  + xlab(xlabelstring) + theme_bw(base_size=14)

```

###*Figure 2*. Means, datapoints, and 95% CI (between & within)  

```{r, echo=FALSE,  fig.width=3, dpi=300}
#Example 2: bar chart with individual data point and 95% CI (between)
ggplot(ci.sum, aes(x=eval(parse(text=paste(factorlabel))), y=eval(parse(text=paste(measurelabel))), group=1)) +
  geom_bar(position=position_dodge(.9), colour="black", stat="identity", fill="white") +
  geom_errorbar(width=.5, size=0.5, aes(ymin=lower, ymax=upper)) +
  geom_errorbar(width=.3, size=0.5, aes(ymin=lower.between, ymax=upper.between)) +
#  geom_point(size=4) +
#  geom_violin(data=alldata.long, aes(group=eval(parse(text=paste(factorlabel)))), alpha=0) +
   geom_point(data=alldata.long, alpha=0.25) +
   ylab(ylabelstring)  + xlab(xlabelstring) + theme_bw(base_size=14)
```

###*Figure 3*. Bar chart displaying means and 95% CI (between)  

```{r, echo=FALSE,  fig.width=3, dpi=300}
#Example 2: bar chart with individual data point and 95% CI (between)
ggplot(ci.sum, aes(x=eval(parse(text=paste(factorlabel))), y=eval(parse(text=paste(measurelabel))), group=1)) +
  geom_bar(position=position_dodge(.9), colour="black", stat="identity", fill="white") +
  geom_errorbar(width=.25, size=0.5, aes(ymin=lower, ymax=upper)) +
#  geom_errorbar(width=0, size=1.1, aes(ymin=lower.between, ymax=upper.between)) +
#  geom_point(size=4) +
#  geom_point(data=alldata.long) +
  ylab(ylabelstring)  + xlab(xlabelstring) + theme_bw(base_size=14)
```

###References

This script uses the *reshape2* package to convert data from wide to long format, the *PoweR* package to perform the normality tests, *HLMdiag* to create the QQplots, *ggplot2* for all plots, *gtable* and *gridExtra* to combine multiple plots into one, *car* to perform Levene's test, *MBESS* to calculate effect sizes and their confidence intervals, *WRS* for the robust statistics, *BayesFactor* for the bayes factor, and *BEST* to calculate the Bayesian highest density interval.

Auguie, B. (2012). *gridExtra: functions in Grid graphics*. R package version 0.9.1, URL: http://CRAN.R-project.org/package=gridExtra.

Baguley, T. (2012). Calculating and graphing within-subject confidence intervals for ANOVA. *Behavior research methods*, *44*, 158-175.

Borenstein, M., Hedges, L. V., Higgins, J. P., & Rothstein, H. R. (2009). *Introduction to meta-analysis*. Hoboken, NJ: Wiley.

Box, G. E. P. (1953). Non-normality and tests on variance. *Biometrika*, *40*, 318-335.

Cumming, G. (2012). *Understanding the new statistics: Effect sizes, confidence intervals, and meta-analysis*. New York: Routledge.

Cohen, J. (1988). *Statistical power analysis for the behavioral sciences (2nd ed.)*. Hillsdale, NJ: Erlbaum.

Fox, J. & Weisberg, S. (2011). *An R Companion to Applied Regression, Second edition*. Sage, Thousand Oaks CA. URL: http://socserv.socsci.mcmaster.ca/jfox/Books/Companion.

Kelley, K. (2005). The effects of nonnormal distributions on confidence intervals around the standardized mean difference: Bootstrap and parametric confidence intervals. *Educational and Psychological Measurement*, *65*, 51-69.

Kelley, K. (2007). Confidence intervals for standardized effect sizes: Theory, application, and implementation. *Journal of Statistical Software*, *20*, 1-24.

Kelley, K. & Lai, K. (2012). *MBESS. R package version 3.3.3*, URL:
http://CRAN.R-project.org/package=MBESS.

Kruschke, J. (2010). *Doing Bayesian data analysis: A tutorial introduction with R*. Academic Press.

Kruschke, J. K. (2013). Bayesian estimation supersedes the t-test. *Journal of Experimental Psychology: General*, *142*, 573-603.

Kruschke, J. K., & Meredith, M. (2014). *BEST: Bayesian Estimation Supersedes the t-test*. R package version 0.2.2, URL: http://CRAN.R-project.org/package=BEST.

Lakens, D. (2013). Calculating and reporting effect sizes to facilitate cumulative science: a practical primer for t-tests and ANOVAs. *Frontiers in psychology*, *4*.

Loy, A., & Hofmann, H. (2014). HLMdiag: A Suite of Diagnostics for Hierarchical Linear Models. R. Journal of Statistical Software, 56, pp. 1-28. URL: http://www.jstatsoft.org/v56/i05/.

McGraw, K. O., & Wong, S. P. (1992). A common language effect size statistic. *Psychological Bulletin*, *111*, 361-365.

Micheaux, PLd. & Tran, V. (2012). PoweR. URL: http://www.biostatisticien.eu/PoweR/.

Morey, R. D. (2008). Confidence intervals from normalized data: A correction to Cousineau (2005). *Tutorial in Quantitative Methods for Psychology*, *4*, 61-64.

Morey, R. D. & Rouder, J. N. (2011). Bayes Factor Approaches for Testing Interval Null Hypotheses. *Psychological Methods*, *16*, 406-419

Morey R and Rouder J (2015). *BayesFactor: Computation of Bayes Factors for Common Designs*. R package version 0.9.11-1, URL: http://CRAN.R-project.org/package=BayesFactor.

Smithson, M. (2001). Correct confidence intervals for various regression effect sizes and parameters: The importance of noncentral distributions in computing intervals. *Educational and Psychological Measurement*, *61*, 605-632.

Rouder, J. N., Speckman, P. L., Sun, D., Morey, R. D., & Iverson, G. (2009). Bayesian t-tests for accepting and rejecting the null hypothesis. *Psychonomic Bulletin & Review*, *16*, 752-760

Wickham, H. (2007). Reshaping Data with the reshape Package. *Journal of Statistical Software*, *21*, pp. 1-20. URL: http://www.jstatsoft.org/v21/i12/.

Wickham, H. (2009). *ggplot2: elegant graphics for data analysis*. Springer New York. ISBN 978-0-387-98140-6, URL: http://had.co.nz/ggplot2/book.

Wickham, H. (2012). *gtable: Arrange grobs in tables*. R package version 0.1.2, URL: http://CRAN.R-project.org/package=gtable.

Wilcox, R. R. (2012). *Introduction to robust estimation and hypothesis testing*. Academic Press.

Wilcox, R. R., & Schönbrodt, F. D. (2015). *The WRS package for robust statistics in R (version 0.27.5)*. URL: https://github.com/nicebread/WRS.


###Apendix A: Data & Session Information

```{r}
alldata

sessionInfo()
```

